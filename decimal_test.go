package decimal

import (
	"errors"
	"fmt"
	"math"
	"testing"
)

func TestDecimal_ZeroValue(t *testing.T) {
	got := Decimal{}
	want := New(0, 0)
	if got != want {
		t.Errorf("Decimal{} = %q, want %q", got, want)
	}
}

func TestNew(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			coef  int64
			scale int
			want  string
		}{
			{math.MinInt64, 0, "-9223372036854775808"},
			{math.MinInt64, 1, "-922337203685477580.8"},
			{math.MinInt64, 2, "-92233720368547758.08"},
			{math.MinInt64, 3, "-9223372036854775.808"},
			{math.MinInt64, 19, "-0.9223372036854775808"},
			{0, 0, "0"},
			{0, 1, "0.0"},
			{0, 2, "0.00"},
			{0, 3, "0.000"},
			{0, 19, "0.0000000000000000000"},
			{1, 0, "1"},
			{1, 1, "0.1"},
			{1, 2, "0.01"},
			{1, 3, "0.001"},
			{1, 19, "0.0000000000000000001"},
			{math.MaxInt64, 0, "9223372036854775807"},
			{math.MaxInt64, 1, "922337203685477580.7"},
			{math.MaxInt64, 2, "92233720368547758.07"},
			{math.MaxInt64, 3, "9223372036854775.807"},
			{math.MaxInt64, 19, "0.9223372036854775807"},
		}
		for _, c := range cases {
			want := MustParse(c.want)
			got := New(c.coef, c.scale)
			if got != want {
				t.Errorf("New(%v, %v) = %q, want %q", c.coef, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			coef  int64
			scale int
		}{
			"scale 1": {0, -1},
			"scale 2": {0, MaxScale + 1},
		}
		for name, c := range cases {
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("New(%v, %v) did not panic", c.coef, c.scale)
					}
				}()
				New(c.coef, c.scale)
			})
		}
	})
}

func TestParse(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d         string
			wantNeg   bool
			wantCoef  uint64
			wantScale int
		}{
			{"-9999999999999999999.0", true, 9999999999999999999, 0},
			{"-9999999999999999999", true, 9999999999999999999, 0},
			{"-999999999999999999.9", true, 9999999999999999999, 1},
			{"-99999999999999999.99", true, 9999999999999999999, 2},
			{"-1000000000000000000.0", true, 1000000000000000000, 0},
			{"-0.9999999999999999999", true, 9999999999999999999, 19},
			{"-00000000000000000000000000000000000001", true, 1, 0},
			{"-1", true, 1, 0},
			{"-1.", true, 1, 0},
			{"-.1", true, 1, 1},
			{"-0.1", true, 1, 1},
			{"-0.01", true, 1, 2},
			{"-0.0000000000000000001", true, 1, 19},
			{"-00000000000000000000000000000000000000", false, 0, 0},
			{"+00000000000000000000000000000000000000", false, 0, 0},
			{"0", false, 0, 0},
			{"0.", false, 0, 0},
			{".0", false, 0, 1},
			{"0.0", false, 0, 1},
			{"0.00", false, 0, 2},
			{"0.000000000000000000", false, 0, 18},
			{"0.0000000000000000000", false, 0, 19},
			{"0.00000000000000000000", false, 0, 19},
			{"00000000000000000000000000000000000001", false, 1, 0},
			{"1", false, 1, 0},
			{"1.", false, 1, 0},
			{".1", false, 1, 1},
			{"0.1", false, 1, 1},
			{"0.01", false, 1, 2},
			{"0.0000000000000000001", false, 1, 19},
			{"1000000000000000000.0", false, 1000000000000000000, 0},
			{"9999999999999999999.0", false, 9999999999999999999, 0},
			{"9999999999999999999", false, 9999999999999999999, 0},
			{"999999999999999999.9", false, 9999999999999999999, 1},
			{"99999999999999999.99", false, 9999999999999999999, 2},
			{"0.9999999999999999999", false, 9999999999999999999, 19},
			// rounding
			{"-0.0000000000000000000000000000000000001", false, 0, 19},
			{"0.0000000000000000000000000000000000001", false, 0, 19},
			{"0.123456789012345678901234567890", false, 1234567890123456789, 19},
			{"-999999999999999999.99", true, 1000000000000000000, 0},
			// exponential notation
			{"1.23e-12", false, 123, 14},
			{"1.23e-5", false, 123, 7},
			{"1.23e-4", false, 123, 6},
			{"1.23e-3", false, 123, 5},
			{"1.23e-2", false, 123, 4},
			{"1.23e-1", false, 123, 3},
			{"1.23e+0", false, 123, 2},
			{"1.23e+1", false, 123, 1},
			{"1.23e+2", false, 123, 0},
			{"1.23e+3", false, 1230, 0},
			{"1.23e+4", false, 12300, 0},
			{"1.23e+5", false, 123000, 0},
			{"1.23e+12", false, 1230000000000, 0},
			{"1e-2", false, 1, 2},
			{"1e-1", false, 1, 1},
			{"1e0", false, 1, 0},
			{"1e+1", false, 10, 0},
			{"1e+2", false, 100, 0},
			{"0.0000000000000000001e-19", false, 0, 19},
			{"0.0000000000000000001e19", false, 1, 0},
			{"1000000000000000000e-19", false, 1000000000000000000, 19},
			{"1000000000000000000e-38", false, 0, 19},
			{"10000000000000000000e-38", false, 1, 19},
			{"100000000000000000000e-38", false, 10, 19},
			{"10000000000000000000000000000000000000e-38", false, 1000000000000000000, 19},
			{"1e+18", false, 1000000000000000000, 0},
			{"0.0000000001e10", false, 1, 0},
			{"10000000000e-10", false, 10000000000, 10},
			{"4E9", false, 4000000000, 0},
			{"0.73e-7", false, 73, 9},
		}
		for _, c := range cases {
			got, err := Parse(c.d)
			if err != nil {
				t.Errorf("Parse(%q) failed: %v", c.d, err)
				continue
			}
			if got.IsNeg() != c.wantNeg {
				t.Errorf("Parse(%q).IsNeg() = %v, want %v", c.d, got.IsNeg(), c.wantNeg)
				continue
			}
			if got.Coef() != c.wantCoef {
				t.Errorf("Parse(%q).Coef() = %v, want %v", c.d, got.Coef(), c.wantCoef)
				continue
			}
			if got.Scale() != c.wantScale {
				t.Errorf("Parse(%q).Scale() = %v, want %v", c.d, got.Scale(), c.wantScale)
				continue
			}
		}
	})

	t.Run("error", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"missing digits 1": {"", 0},
			"missing digits 2": {"+", 0},
			"missing digits 3": {"-", 0},
			"missing digits 4": {".", 0},
			"invalid char 1":   {"+e", 0},
			"invalid char 2":   {"-e", 0},
			"invalid char 3":   {"e+", 0},
			"invalid char 4":   {"e-", 0},
			"invalid char 5":   {"e.0", 0},
			"missing exp 1":    {"0.e", 0},
			"missing exp 2":    {"1e", 0},
			"exp range 1":      {"1e-39", 0},
			"exp range 2":      {"1e39", 0},
			"double sign 1":    {"++1", 0},
			"double sign 2":    {"--1", 0},
			"double sign 3":    {"+-1", 0},
			"double sign 4":    {"-+1", 0},
			"double dot 1":     {"1.00.00", 0},
			"special value 1":  {"Inf", 0},
			"special value 2":  {"-infinity", 0},
			"special value 3":  {"NaN", 0},
			"overflow 1":       {"-10000000000000000000", 0},
			"overflow 2":       {"-99999999999999999990", 0},
			"overflow 3":       {"10000000000000000000", 0},
			"overflow 4":       {"99999999999999999990", 0},
			"overflow 5":       {"1234567890123456789012345678901234567890", 0},
			"overflow 6":       {"0.1234567890123456789012345678901234567890", 0},
			"scale 1":          {"0", -1},
			"scale 2":          {"0", MaxScale + 1},
			"scale 3":          {"10", MaxScale},
			"scale 4":          {"100", MaxScale - 1},
		}
		for name, c := range cases {
			t.Run(name, func(t *testing.T) {
				_, err := ParseExact(c.d, c.scale)
				if err == nil {
					t.Errorf("ParseExact(%q, %v) did not return error", c.d, c.scale)
					return
				}
			})
		}
	})
}

func TestDecimal_String(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			neg   bool
			coef  fint
			scale int
			want  string
		}{
			{true, maxCoef, 0, "-9999999999999999999"},
			{true, maxCoef, 1, "-999999999999999999.9"},
			{true, maxCoef, 2, "-99999999999999999.99"},
			{true, maxCoef, 3, "-9999999999999999.999"},
			{true, maxCoef, 19, "-0.9999999999999999999"},
			{true, 1, 0, "-1"},
			{true, 1, 1, "-0.1"},
			{true, 1, 2, "-0.01"},
			{true, 1, 19, "-0.0000000000000000001"},
			{false, 0, 0, "0"},
			{false, 0, 1, "0.0"},
			{false, 0, 2, "0.00"},
			{false, 0, 19, "0.0000000000000000000"},
			{false, 1, 0, "1"},
			{false, 1, 1, "0.1"},
			{false, 1, 2, "0.01"},
			{false, 1, 19, "0.0000000000000000001"},
			{false, maxCoef, 0, "9999999999999999999"},
			{false, maxCoef, 1, "999999999999999999.9"},
			{false, maxCoef, 2, "99999999999999999.99"},
			{false, maxCoef, 3, "9999999999999999.999"},
			{false, maxCoef, 19, "0.9999999999999999999"},
		}
		for _, c := range cases {
			d, err := newDecimal(c.neg, c.coef, c.scale)
			if err != nil {
				t.Errorf("newDecimal(%v, %v, %v) failed: %v", c.neg, c.coef, c.scale, err)
				continue
			}
			got := d.String()
			if got != c.want {
				t.Errorf("newDecimal(%v, %v, %v).String() = %q, want %q", c.neg, c.coef, c.scale, got, c.want)
			}
		}
	})
}

func TestDecimal_Format(t *testing.T) {

	cases := []struct {
		d, format, want string
	}{
		// %T verb
		{"12.34", "%T", "decimal.Decimal"},
		// %q verb
		{"12.34", "%q", "\"12.34\""},
		{"12.34", "%+q", "\"+12.34\""},
		{"12.34", "%.6q", "\"12.34\""}, // precision is ignored
		{"12.34", "%7q", "\"12.34\""},
		{"12.34", "%8q", " \"12.34\""},
		{"12.34", "%9q", "  \"12.34\""},
		{"12.34", "%10q", "   \"12.34\""},
		{"12.34", "%010q", "\"00012.34\""},
		{"12.34", "%+10q", "  \"+12.34\""},
		{"12.34", "%-10q", "\"12.34\"   "},
		// %s verb
		{"12.34", "%s", "12.34"},
		{"12.34", "%+s", "+12.34"},
		{"12.34", "%.6s", "12.34"}, // precision is ignored
		{"12.34", "%7s", "  12.34"},
		{"12.34", "%8s", "   12.34"},
		{"12.34", "%9s", "    12.34"},
		{"12.34", "%10s", "     12.34"},
		{"12.34", "%010s", "0000012.34"},
		{"12.34", "%+10s", "    +12.34"},
		{"12.34", "%-10s", "12.34     "},
		// %v verb
		{"12.34", "%v", "12.34"},
		{"12.34", "% v", " 12.34"},
		{"12.34", "%+v", "+12.34"},
		{"12.34", "%.6v", "12.34"}, // precision is ignored
		{"12.34", "%7v", "  12.34"},
		{"12.34", "%8v", "   12.34"},
		{"12.34", "%9v", "    12.34"},
		{"12.34", "%10v", "     12.34"},
		{"12.34", "%010v", "0000012.34"},
		{"12.34", "%+10v", "    +12.34"},
		{"12.34", "%-10v", "12.34     "},
		// %k verb
		{"12.34", "%k", "1234%"},
		{"12.34", "%+k", "+1234%"},
		{"12.34", "%.1k", "1234.0%"},
		{"12.34", "%.2k", "1234.00%"},
		{"12.34", "%.3k", "1234.000%"},
		{"12.34", "%.4k", "1234.0000%"},
		{"12.34", "%.5k", "1234.00000%"},
		{"12.34", "%.6k", "1234.000000%"},
		{"12.34", "%7k", "  1234%"},
		{"12.34", "%8k", "   1234%"},
		{"12.34", "%9k", "    1234%"},
		{"12.34", "%10k", "     1234%"},
		{"12.34", "%010k", "000001234%"},
		{"12.34", "%+10k", "    +1234%"},
		{"12.34", "%-10k", "1234%     "},
		{"2.3", "%k", "230%"},
		{"0.23", "%k", "23%"},
		{"0.023", "%k", "2.3%"},
		{"2.30", "%k", "230%"},
		{"0.230", "%k", "23.0%"},
		{"0.0230", "%k", "2.30%"},
		{"2.300", "%k", "230.0%"},
		{"0.2300", "%k", "23.00%"},
		{"0.02300", "%k", "2.300%"},
		// %f verb
		{"12.34", "%f", "12.34"},
		{"12.34", "%+f", "+12.34"},
		{"12.34", "%.1f", "12.3"},
		{"12.34", "%.2f", "12.34"},
		{"12.34", "%.3f", "12.340"},
		{"12.34", "%.4f", "12.3400"},
		{"12.34", "%.5f", "12.34000"},
		{"12.34", "%.6f", "12.340000"},
		{"12.34", "%7f", "  12.34"},
		{"12.34", "%8f", "   12.34"},
		{"12.34", "%9f", "    12.34"},
		{"12.34", "%10f", "     12.34"},
		{"12.34", "%010f", "0000012.34"},
		{"12.34", "%+10f", "    +12.34"},
		{"12.34", "%-10f", "12.34     "},
		{"12.34", "%.1f", "12.3"},
		{"0", "%.2f", "0.00"},
		{"0", "%5.2f", " 0.00"},
		{"9.996208266660", "%.2f", "10.00"},
		{"0.9996208266660", "%.2f", "1.00"},
		{"0.09996208266660", "%.2f", "0.10"},
		{"0.009996208266660", "%.2f", "0.01"},
		{"500.44", "%6.1f", " 500.4"},
		{"-404.040", "%-010.f", "-404      "},
		{"-404.040", "%-10.f", "-404      "},
		{"1", "%.20f", "1.00000000000000000000"},
		{"1.000000000000000000", "%.20f", "1.00000000000000000000"},
		{"9999999999999999999", "%.1f", "9999999999999999999.0"},
		// wrong verbs
		{"12.34", "%b", "%!b(decimal.Decimal=12.34)"},
		{"12.34", "%e", "%!e(decimal.Decimal=12.34)"},
		{"12.34", "%E", "%!E(decimal.Decimal=12.34)"},
		{"12.34", "%g", "%!g(decimal.Decimal=12.34)"},
		{"12.34", "%G", "%!G(decimal.Decimal=12.34)"},
		{"12.34", "%x", "%!x(decimal.Decimal=12.34)"},
		{"12.34", "%X", "%!X(decimal.Decimal=12.34)"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		got := fmt.Sprintf(c.format, d)
		if got != c.want {
			t.Errorf("fmt.Sprintf(%q, %q) = %q, want %q", c.format, c.d, got, c.want)
		}
	}
}

func TestDecimal_Prec(t *testing.T) {
	cases := []struct {
		d    string
		want int
	}{
		{"0000", 0},
		{"000", 0},
		{"00", 0},
		{"0", 0},
		{"0.000", 0},
		{"0.00", 0},
		{"0.0", 0},
		{"0", 0},
		{"0.0000000000000000001", 1},
		{"0.000000000000000001", 1},
		{"0.00000000000000001", 1},
		{"0.0000000000000001", 1},
		{"0.000000000000001", 1},
		{"0.00000000000001", 1},
		{"0.0000000000001", 1},
		{"0.000000000001", 1},
		{"0.00000000001", 1},
		{"0.0000000001", 1},
		{"0.000000001", 1},
		{"0.00000001", 1},
		{"0.0000001", 1},
		{"0.000001", 1},
		{"0.00001", 1},
		{"0.0001", 1},
		{"0.001", 1},
		{"0.01", 1},
		{"0.1", 1},
		{"1", 1},
		{"0.1000000000000000000", 19},
		{"0.100000000000000000", 18},
		{"0.10000000000000000", 17},
		{"0.1000000000000000", 16},
		{"0.100000000000000", 15},
		{"0.10000000000000", 14},
		{"0.1000000000000", 13},
		{"0.100000000000", 12},
		{"0.10000000000", 11},
		{"0.1000000000", 10},
		{"0.100000000", 9},
		{"0.10000000", 8},
		{"0.1000000", 7},
		{"0.100000", 6},
		{"0.10000", 5},
		{"0.1000", 4},
		{"0.100", 3},
		{"0.10", 2},
		{"0.1", 1},
		{"1", 1},
		{"10", 2},
		{"100", 3},
		{"1000", 4},
		{"10000", 5},
		{"100000", 6},
		{"1000000", 7},
		{"10000000", 8},
		{"100000000", 9},
		{"1000000000", 10},
		{"10000000000", 11},
		{"100000000000", 12},
		{"1000000000000", 13},
		{"10000000000000", 14},
		{"100000000000000", 15},
		{"1000000000000000", 16},
		{"10000000000000000", 17},
		{"100000000000000000", 18},
		{"1000000000000000000", 19},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		got := d.Prec()
		if got != c.want {
			t.Errorf("%q.Prec() = %v, want %v", c.d, got, c.want)
		}
	}
}

func TestDecimal_WithScale(t *testing.T) {
	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d     string
			scale int
			want  string
		}{
			{"0", 0, "0"},
			{"0", 1, "0.0"},
			{"0", 2, "0.00"},
			{"0", 3, "0.000"},
			{"0", 19, "0.0000000000000000000"},
			{"1", 0, "1"},
			{"1", 1, "0.1"},
			{"1", 2, "0.01"},
			{"1", 3, "0.001"},
			{"1", 19, "0.0000000000000000001"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.WithScale(c.scale)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.WithScale(%v) = %q, want %q", c.d, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"scale 1": {"0", -1},
			"scale 2": {"0", MaxScale + 1},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.WithScale(%v) did not panic", c.d, c.scale)
					}
				}()
				d.WithScale(c.scale)
			})
		}
	})
}

func TestDecimal_Round(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d     string
			scale int
			want  string
		}{
			// Zeroes
			{"0", 0, "0"},
			{"0", 1, "0.0"},
			{"0", 2, "0.00"},
			{"0", 19, "0.0000000000000000000"},
			{"0.0", 1, "0.0"},
			{"0.00", 2, "0.00"},
			{"0.000000000", 19, "0.0000000000000000000"},
			{"0.000000000", 0, "0"},
			{"0.000000000", 1, "0.0"},
			{"0.000000000", 2, "0.00"},

			// Tests from GDE
			{"2.17", 0, "2"},
			{"2.17", 1, "2.2"},
			{"2.17", 2, "2.17"},
			{"2.17", 9, "2.170000000"},
			{"1.2345", 2, "1.23"},
			{"1.2355", 2, "1.24"},
			{"1.2345", 9, "1.234500000"},
			{"9.9999", 2, "10.00"},
			{"0.0001", 2, "0.00"},
			{"0.001", 2, "0.00"},
			{"0.009", 2, "0.01"},

			// Some extra tests
			{"0.03", 2, "0.03"},
			{"0.02", 2, "0.02"},
			{"0.01", 2, "0.01"},
			{"0.00", 2, "0.00"},
			{"-0.01", 2, "-0.01"},
			{"-0.02", 2, "-0.02"},
			{"-0.03", 2, "-0.03"},
			{"0.0049", 2, "0.00"},
			{"0.0051", 2, "0.01"},
			{"0.0149", 2, "0.01"},
			{"0.0151", 2, "0.02"},
			{"-0.0049", 2, "0.00"},
			{"-0.0051", 2, "-0.01"},
			{"-0.0149", 2, "-0.01"},
			{"-0.0151", 2, "-0.02"},
			{"0.0050", 2, "0.00"},
			{"0.0150", 2, "0.02"},
			{"0.0250", 2, "0.02"},
			{"0.0350", 2, "0.04"},
			{"-0.0050", 2, "0.00"},
			{"-0.0150", 2, "-0.02"},
			{"-0.0250", 2, "-0.02"},
			{"-0.0350", 2, "-0.04"},
			{"3.0448", 2, "3.04"},
			{"3.0450", 2, "3.04"},
			{"3.0452", 2, "3.05"},
			{"3.0956", 2, "3.10"},

			// Tests from Wikipedia
			{"1.8", 0, "2"},
			{"1.5", 0, "2"},
			{"1.2", 0, "1"},
			{"0.8", 0, "1"},
			{"0.5", 0, "0"},
			{"0.2", 0, "0"},
			{"-0.2", 0, "0"},
			{"-0.5", 0, "0"},
			{"-0.8", 0, "-1"},
			{"-1.2", 0, "-1"},
			{"-1.5", 0, "-2"},
			{"-1.8", 0, "-2"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.Round(c.scale)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.Round(%v) = %q, want %q", c.d, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"overflow 1":    {"1000000000000000000", 1},
			"overflow 2":    {"100000000000000000", 2},
			"overflow 3":    {"10000000000000000", 3},
			"overflow 4":    {"1000000000000000", 4},
			"overflow 5":    {"100000000000000", 5},
			"overflow 6":    {"10000000000000", 6},
			"overflow 7":    {"1000000000000", 7},
			"large scale 1": {"1", 20},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.Round(%v) did not panic", c.d, c.scale)
					}
				}()
				d.Round(c.scale)
			})
		}
	})
}

func TestDecimal_Quantize(t *testing.T) {
	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d, e, want string
		}{
			{"0", "0", "0"},
			{"0", "0.0", "0.0"},
			{"0.0", "0", "0"},
			{"0.0", "0.0", "0.0"},

			{"0.0078", "0.00001", "0.00780"},
			{"0.0078", "0.0001", "0.0078"},
			{"0.0078", "0.001", "0.008"},
			{"0.0078", "0.01", "0.01"},
			{"0.0078", "0.1", "0.0"},
			{"0.0078", "1", "0"},

			{"-0.0078", "0.00001", "-0.00780"},
			{"-0.0078", "0.0001", "-0.0078"},
			{"-0.0078", "0.001", "-0.008"},
			{"-0.0078", "0.01", "-0.01"},
			{"-0.0078", "0.1", "0.0"},
			{"-0.0078", "1", "0"},

			{"0.6666666", "0.1", "0.7"},
			{"9.9999", "1.00", "10.00"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			want := MustParse(c.want)
			got := d.Quantize(e)
			if got != want {
				t.Errorf("%q.Quantize(%q) = %q, want %q", d, e, got, want)
			}
		}
	})
}

func TestDecimal_Trunc(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d     string
			scale int
			want  string
		}{
			// Zeroes
			{"0", 0, "0"},
			{"0", 1, "0.0"},
			{"0", 2, "0.00"},
			{"0", 19, "0.0000000000000000000"},
			{"0.0", 1, "0.0"},
			{"0.00", 2, "0.00"},
			{"0.000000000", 19, "0.0000000000000000000"},
			{"0.000000000", 0, "0"},
			{"0.000000000", 1, "0.0"},
			{"0.000000000", 2, "0.00"},

			// Tests from GDE
			{"2.17", 0, "2"},
			{"2.17", 1, "2.1"},
			{"2.17", 2, "2.17"},
			{"2.17", 9, "2.170000000"},
			{"1.2345", 2, "1.23"},
			{"1.2355", 2, "1.23"},
			{"1.2345", 9, "1.234500000"},
			{"9.9999", 2, "9.99"},
			{"0.0001", 2, "0.00"},
			{"0.001", 2, "0.00"},
			{"0.009", 2, "0.00"},

			// Some extra tests
			{"0.03", 2, "0.03"},
			{"0.02", 2, "0.02"},
			{"0.01", 2, "0.01"},
			{"0.00", 2, "0.00"},
			{"-0.01", 2, "-0.01"},
			{"-0.02", 2, "-0.02"},
			{"-0.03", 2, "-0.03"},
			{"0.0049", 2, "0.00"},
			{"0.0051", 2, "0.00"},
			{"0.0149", 2, "0.01"},
			{"0.0151", 2, "0.01"},
			{"-0.0049", 2, "0.00"},
			{"-0.0051", 2, "-0.00"},
			{"-0.0149", 2, "-0.01"},
			{"-0.0151", 2, "-0.01"},
			{"0.0050", 2, "0.00"},
			{"0.0150", 2, "0.01"},
			{"0.0250", 2, "0.02"},
			{"0.0350", 2, "0.03"},
			{"-0.0050", 2, "0.00"},
			{"-0.0150", 2, "-0.01"},
			{"-0.0250", 2, "-0.02"},
			{"-0.0350", 2, "-0.03"},
			{"3.0448", 2, "3.04"},
			{"3.0450", 2, "3.04"},
			{"3.0452", 2, "3.04"},
			{"3.0956", 2, "3.09"},

			// Tests from Wikipedia
			{"1.8", 0, "1"},
			{"1.5", 0, "1"},
			{"1.2", 0, "1"},
			{"0.8", 0, "0"},
			{"0.5", 0, "0"},
			{"0.2", 0, "0"},
			{"-0.2", 0, "0"},
			{"-0.5", 0, "0"},
			{"-0.8", 0, "0"},
			{"-1.2", 0, "-1"},
			{"-1.5", 0, "-1"},
			{"-1.8", 0, "-1"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.Trunc(c.scale)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.Trunc(%v) = %q, want %q", c.d, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"overflow 1": {"1000000000000000000", 1},
			"overflow 2": {"100000000000000000", 2},
			"overflow 3": {"10000000000000000", 3},
			"overflow 4": {"1000000000000000", 4},
			"overflow 5": {"100000000000000", 5},
			"overflow 6": {"10000000000000", 6},
			"overflow 7": {"1000000000000", 7},
			"scale 1":    {"1", 20},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.Trunc(%v) did not panic", c.d, c.scale)
					}
				}()
				d.Trunc(c.scale)
			})
		}
	})
}

func TestDecimal_Ceil(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			e     string
			scale int
			want  string
		}{
			// Zeroes
			{"0", 0, "0"},
			{"0", 1, "0.0"},
			{"0", 2, "0.00"},
			{"0", 19, "0.0000000000000000000"},
			{"0.0", 1, "0.0"},
			{"0.00", 2, "0.00"},
			{"0.000000000", 19, "0.0000000000000000000"},
			{"0.000000000", 0, "0"},
			{"0.000000000", 1, "0.0"},
			{"0.000000000", 2, "0.00"},

			// Tests from GDE
			{"2.17", 0, "3"},
			{"2.17", 1, "2.2"},
			{"2.17", 2, "2.17"},
			{"2.17", 9, "2.170000000"},
			{"1.2345", 2, "1.24"},
			{"1.2355", 2, "1.24"},
			{"1.2345", 9, "1.234500000"},
			{"9.9999", 2, "10.00"},
			{"0.0001", 2, "0.01"},
			{"0.001", 2, "0.01"},
			{"0.009", 2, "0.01"},
			{"-2.17", 0, "-2"},
			{"-2.17", 1, "-2.1"},
			{"-2.17", 2, "-2.17"},
			{"-2.17", 9, "-2.170000000"},
			{"-1.2345", 2, "-1.23"},
			{"-1.2355", 2, "-1.23"},
			{"-1.2345", 9, "-1.234500000"},
			{"-9.9999", 2, "-9.99"},
			{"-0.0001", 2, "0.00"},
			{"-0.001", 2, "0.00"},
			{"-0.009", 2, "0.00"},

			// Some extra tests
			{"0.03", 2, "0.03"},
			{"0.02", 2, "0.02"},
			{"0.01", 2, "0.01"},
			{"0.00", 2, "0.00"},
			{"-0.01", 2, "-0.01"},
			{"-0.02", 2, "-0.02"},
			{"-0.03", 2, "-0.03"},
			{"0.0049", 2, "0.01"},
			{"0.0051", 2, "0.01"},
			{"0.0149", 2, "0.02"},
			{"0.0151", 2, "0.02"},
			{"-0.0049", 2, "0.00"},
			{"-0.0051", 2, "0.00"},
			{"-0.0149", 2, "-0.01"},
			{"-0.0151", 2, "-0.01"},
			{"0.0050", 2, "0.01"},
			{"0.0150", 2, "0.02"},
			{"0.0250", 2, "0.03"},
			{"0.0350", 2, "0.04"},
			{"-0.0050", 2, "0.00"},
			{"-0.0150", 2, "-0.01"},
			{"-0.0250", 2, "-0.02"},
			{"-0.0350", 2, "-0.03"},
			{"3.0448", 2, "3.05"},
			{"3.0450", 2, "3.05"},
			{"3.0452", 2, "3.05"},
			{"3.0956", 2, "3.10"},

			// Tests from Wikipedia
			{"1.8", 0, "2"},
			{"1.5", 0, "2"},
			{"1.2", 0, "2"},
			{"0.8", 0, "1"},
			{"0.5", 0, "1"},
			{"0.2", 0, "1"},
			{"-0.2", 0, "0"},
			{"-0.5", 0, "0"},
			{"-0.8", 0, "0"},
			{"-1.2", 0, "-1"},
			{"-1.5", 0, "-1"},
			{"-1.8", 0, "-1"},
		}
		for _, c := range cases {
			d := MustParse(c.e)
			got := d.Ceil(c.scale)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.Ceil(%v) = %q, want %q", c.e, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"overflow 1":    {"1000000000000000000", 1},
			"overflow 2":    {"100000000000000000", 2},
			"overflow 3":    {"10000000000000000", 3},
			"overflow 4":    {"1000000000000000", 4},
			"overflow 5":    {"100000000000000", 5},
			"overflow 6":    {"10000000000000", 6},
			"overflow 7":    {"1000000000000", 7},
			"large scale 1": {"1", 20},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.Ceil(%v) did not panic", c.d, c.scale)
					}
				}()
				d.Ceil(c.scale)
			})
		}
	})
}

func TestDecimal_Floor(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d     string
			scale int
			want  string
		}{
			// Zeroes
			{"0", 0, "0"},
			{"0", 1, "0.0"},
			{"0", 2, "0.00"},
			{"0", 19, "0.0000000000000000000"},
			{"0.0", 1, "0.0"},
			{"0.00", 2, "0.00"},
			{"0.000000000", 19, "0.0000000000000000000"},
			{"0.000000000", 0, "0"},
			{"0.000000000", 1, "0.0"},
			{"0.000000000", 2, "0.00"},

			// Tests from GDE
			{"2.17", 0, "2"},
			{"2.17", 1, "2.1"},
			{"2.17", 2, "2.17"},
			{"2.17", 9, "2.170000000"},
			{"1.2345", 2, "1.23"},
			{"1.2355", 2, "1.23"},
			{"1.2345", 9, "1.234500000"},
			{"9.9999", 2, "9.99"},
			{"0.0001", 2, "0.00"},
			{"0.001", 2, "0.00"},
			{"0.009", 2, "0.00"},
			{"-2.17", 0, "-3"},
			{"-2.17", 1, "-2.2"},
			{"-2.17", 2, "-2.17"},
			{"-2.17", 9, "-2.170000000"},
			{"-1.2345", 2, "-1.24"},
			{"-1.2355", 2, "-1.24"},
			{"-1.2345", 9, "-1.234500000"},
			{"-9.9999", 2, "-10.00"},
			{"-0.0001", 2, "-0.01"},
			{"-0.001", 2, "-0.01"},
			{"-0.009", 2, "-0.01"},

			// Some extra tests
			{"0.03", 2, "0.03"},
			{"0.02", 2, "0.02"},
			{"0.01", 2, "0.01"},
			{"0.00", 2, "0.00"},
			{"-0.01", 2, "-0.01"},
			{"-0.02", 2, "-0.02"},
			{"-0.03", 2, "-0.03"},
			{"0.0049", 2, "0.00"},
			{"0.0051", 2, "0.00"},
			{"0.0149", 2, "0.01"},
			{"0.0151", 2, "0.01"},
			{"-0.0049", 2, "-0.01"},
			{"-0.0051", 2, "-0.01"},
			{"-0.0149", 2, "-0.02"},
			{"-0.0151", 2, "-0.02"},
			{"0.0050", 2, "0.00"},
			{"0.0150", 2, "0.01"},
			{"0.0250", 2, "0.02"},
			{"0.0350", 2, "0.03"},
			{"-0.0050", 2, "-0.01"},
			{"-0.0150", 2, "-0.02"},
			{"-0.0250", 2, "-0.03"},
			{"-0.0350", 2, "-0.04"},
			{"3.0448", 2, "3.04"},
			{"3.0450", 2, "3.04"},
			{"3.0452", 2, "3.04"},
			{"3.0956", 2, "3.09"},

			// Tests from Wikipedia
			{"1.8", 0, "1"},
			{"1.5", 0, "1"},
			{"1.2", 0, "1"},
			{"0.8", 0, "0"},
			{"0.5", 0, "0"},
			{"0.2", 0, "0"},
			{"-0.2", 0, "-1"},
			{"-0.5", 0, "-1"},
			{"-0.8", 0, "-1"},
			{"-1.2", 0, "-2"},
			{"-1.5", 0, "-2"},
			{"-1.8", 0, "-2"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.Floor(c.scale)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.Floor(%v) = %q, want %q", c.d, c.scale, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			scale int
		}{
			"overflow 1":    {"1000000000000000000", 1},
			"overflow 2":    {"100000000000000000", 2},
			"overflow 3":    {"10000000000000000", 3},
			"overflow 4":    {"1000000000000000", 4},
			"overflow 5":    {"100000000000000", 5},
			"overflow 6":    {"10000000000000", 6},
			"overflow 7":    {"1000000000000", 7},
			"large scale 1": {"1", 20},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.Floor(%v) did not panic", c.d, c.scale)
					}
				}()
				d.Floor(c.scale)
			})
		}
	})
}

func TestDecimal_MinScale(t *testing.T) {
	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d    string
			want int
		}{
			{"0", 0},
			{"0.0", 0},
			{"1", 0},
			{"1.000000000", 0},
			{"0.100000000", 1},
			{"0.010000000", 2},
			{"0.001000000", 3},
			{"0.000100000", 4},
			{"0.000010000", 5},
			{"0.000001000", 6},
			{"0.000000100", 7},
			{"0.000000010", 8},
			{"0.000000001", 9},
			{"0.000000000", 0},
			{"0.0000000000000000000", 0},
			{"0.1000000000000000000", 1},
			{"0.0000000000000000001", 19},
			{"0.9999999999999999999", 19},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.MinScale()
			if got != c.want {
				t.Errorf("%q.MinScale() = %v, want %v", d, got, c.want)
			}
		}
	})
}

func TestDecimal_Reduce(t *testing.T) {
	cases := []struct {
		d, want string
	}{
		{"0.0000000", "0"},
		{"-10.00", "-10"},
		{"10.00", "10"},
		{"0.000001", "0.000001"},
		{"0.0000010", "0.000001"},
		{"-0.000001", "-0.000001"},
		{"-0.0000010", "-0.000001"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		want := MustParse(c.want)
		got := d.Reduce()
		if got != want {
			t.Errorf("%q.Reduce() = %q, want %q", d, got, want)
		}
	}
}

func TestDecimal_Add(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d, e, want string
		}{
			{"1", "1", "2"},
			{"2", "3", "5"},
			{"5.75", "3.3", "9.05"},
			{"5", "-3", "2"},
			{"-5", "-3", "-8"},
			{"-7", "2.5", "-4.5"},
			{"0.7", "0.3", "1.0"},
			{"1.25", "1.25", "2.50"},
			{"1.1", "0.11", "1.21"},
			{"1.234567890", "1.000000000", "2.234567890"},
			{"1.234567890", "1.000000110", "2.234568000"},

			{"0.9998", "0.0000", "0.9998"},
			{"0.9998", "0.0001", "0.9999"},
			{"0.9998", "0.0002", "1.0000"},
			{"0.9998", "0.0003", "1.0001"},

			{"999999999999999999", "1", "1000000000000000000"},
			{"99999999999999999", "1", "100000000000000000"},
			{"9999999999999999", "1", "10000000000000000"},
			{"999999999999999", "1", "1000000000000000"},
			{"99999999999999", "1", "100000000000000"},
			{"9999999999999", "1", "10000000000000"},
			{"999999999999", "1", "1000000000000"},
			{"99999999999", "1", "100000000000"},
			{"9999999999", "1", "10000000000"},
			{"999999999", "1", "1000000000"},
			{"99999999", "1", "100000000"},
			{"9999999", "1", "10000000"},
			{"999999", "1", "1000000"},
			{"99999", "1", "100000"},
			{"9999", "1", "10000"},
			{"999", "1", "1000"},
			{"99", "1", "100"},
			{"9", "1", "10"},

			{"100000000000", "0.00000000", "100000000000.0000000"},
			{"100000000000", "0.00000001", "100000000000.0000000"},

			{"0.0", "0", "0.0"},
			{"0.00", "0", "0.00"},
			{"0.000", "0", "0.000"},
			{"0.0000000", "0", "0.0000000"},
			{"0", "0.0", "0.0"},
			{"0", "0.00", "0.00"},
			{"0", "0.000", "0.000"},
			{"0", "0.0000000", "0.0000000"},

			{"9999999999999999999", "0.4", "9999999999999999999"},
			{"-9999999999999999999", "-0.4", "-9999999999999999999"},
			{"1", "-9999999999999999999", "-9999999999999999998"},
			{"9999999999999999999", "-1", "9999999999999999998"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			want := MustParse(c.want)
			got := d.Add(e)
			if got != want {
				t.Errorf("%q.Add(%q) = %q, want %q", d, e, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d, e  string
			scale int
		}{
			"overflow 1": {"9999999999999999999", "1", 0},
			"overflow 2": {"9999999999999999999", "0.6", 0},
			"overflow 3": {"-9999999999999999999", "-1", 0},
			"overflow 4": {"-9999999999999999999", "-0.6", 0},
			"scale 1":    {"0", "0", -1},
			"scale 2":    {"0", "0", MaxScale + 1},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.AddExact(%q, %v) did not panic", d, e, c.scale)
					}
				}()
				d.AddExact(e, c.scale)
			})
		}
	})
}

func TestDecimal_Mul(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d, e, want string
		}{
			{"2", "2", "4"},
			{"2", "3", "6"},
			{"5", "1", "5"},
			{"5", "2", "10"},
			{"1.20", "2", "2.40"},
			{"1.20", "0", "0.00"},
			{"1.20", "-2", "-2.40"},
			{"-1.20", "2", "-2.40"},
			{"-1.20", "0", "0.00"},
			{"-1.20", "-2", "2.40"},
			{"5.09", "7.1", "36.139"},
			{"2.5", "4", "10.0"},
			{"2.50", "4", "10.00"},
			{"0.70", "1.05", "0.7350"},
			{"1.000000000", "1", "1.000000000"},
			{"1.23456789", "1.00000000", "1.2345678900000000"},
			{"1.000000000000000000", "1.000000000000000000", "1.000000000000000000"},
			{"1.000000000000000001", "1.000000000000000001", "1.000000000000000002"},
			{"9.999999999999999999", "9.999999999999999999", "99.99999999999999998"},
			{"0.0000000000000000001", "0.0000000000000000001", "0.0000000000000000000"},
			{"0.0000000000000000001", "0.9999999999999999999", "0.0000000000000000001"},
			{"0.0000000000000000003", "0.9999999999999999999", "0.0000000000000000003"},
			{"0.9999999999999999999", "0.9999999999999999999", "0.9999999999999999998"},
			{"6963.788300835654596", "0.001436", "10.00000000000000000"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			want := MustParse(c.want)
			got := d.Mul(e)
			if got != want {
				t.Errorf("%q.Mul(%q) = %q, want %q", d, e, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d, e  string
			scale int
		}{
			"overflow 1": {"10000000000", "1000000000", 0},
			"overflow 2": {"1000000000000000000", "10", 0},
			"scale 1":    {"0", "0", -1},
			"scale 2":    {"0", "0", MaxScale + 1},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.MulExact(%q, %v) did not panic", d, e, c.scale)
					}
				}()
				d.MulExact(e, c.scale)
			})
		}
	})
}

func TestDecimal_FMA(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d, e, f, want string
		}{
			// Sign
			{"2", "3", "4", "10"},
			{"2", "3", "-4", "2"},
			{"2", "-3", "4", "-2"},
			{"2", "-3", "-4", "-10"},
			{"-2", "3", "4", "-2"},
			{"-2", "3", "-4", "-10"},
			{"-2", "-3", "4", "10"},
			{"-2", "-3", "-4", "2"},

			// Addition tests
			{"1", "1", "1", "2"},
			{"1", "2", "3", "5"},
			{"1", "5.75", "3.3", "9.05"},
			{"1", "5", "-3", "2"},
			{"1", "-5", "-3", "-8"},
			{"1", "-7", "2.5", "-4.5"},
			{"1", "0.7", "0.3", "1.0"},
			{"1", "1.25", "1.25", "2.50"},
			{"1", "1.1", "0.11", "1.21"},
			{"1", "1.234567890", "1.000000000", "2.234567890"},
			{"1", "1.234567890", "1.000000110", "2.234568000"},
			{"1", "0.9998", "0.0000", "0.9998"},
			{"1", "0.9998", "0.0001", "0.9999"},
			{"1", "0.9998", "0.0002", "1.0000"},
			{"1", "0.9998", "0.0003", "1.0001"},
			{"1", "999999999999999999", "1", "1000000000000000000"},
			{"1", "99999999999999999", "1", "100000000000000000"},
			{"1", "9999999999999999", "1", "10000000000000000"},
			{"1", "999999999999999", "1", "1000000000000000"},
			{"1", "99999999999999", "1", "100000000000000"},
			{"1", "9999999999999", "1", "10000000000000"},
			{"1", "999999999999", "1", "1000000000000"},
			{"1", "99999999999", "1", "100000000000"},
			{"1", "9999999999", "1", "10000000000"},
			{"1", "999999999", "1", "1000000000"},
			{"1", "99999999", "1", "100000000"},
			{"1", "9999999", "1", "10000000"},
			{"1", "999999", "1", "1000000"},
			{"1", "99999", "1", "100000"},
			{"1", "9999", "1", "10000"},
			{"1", "999", "1", "1000"},
			{"1", "99", "1", "100"},
			{"1", "9", "1", "10"},
			{"1", "100000000000", "0.00000000", "100000000000.0000000"},
			{"1", "100000000000", "0.00000001", "100000000000.0000000"},
			{"1", "0.0", "0", "0.0"},
			{"1", "0.00", "0", "0.00"},
			{"1", "0.000", "0", "0.000"},
			{"1", "0.0000000", "0", "0.0000000"},
			{"1", "0", "0.0", "0.0"},
			{"1", "0", "0.00", "0.00"},
			{"1", "0", "0.000", "0.000"},
			{"1", "0", "0.0000000", "0.0000000"},
			{"1", "9999999999999999999", "0.4", "9999999999999999999"},
			{"1", "-9999999999999999999", "-0.4", "-9999999999999999999"},
			{"1", "1", "-9999999999999999999", "-9999999999999999998"},
			{"1", "9999999999999999999", "-1", "9999999999999999998"},

			// Multiplication tests
			{"2", "2", "0", "4"},
			{"2", "3", "0", "6"},
			{"5", "1", "0", "5"},
			{"5", "2", "0", "10"},
			{"1.20", "2", "0", "2.40"},
			{"1.20", "0", "0", "0.00"},
			{"1.20", "-2", "0", "-2.40"},
			{"-1.20", "2", "0", "-2.40"},
			{"-1.20", "0", "0", "0.00"},
			{"-1.20", "-2", "0", "2.40"},
			{"5.09", "7.1", "0", "36.139"},
			{"2.5", "4", "0", "10.0"},
			{"2.50", "4", "0", "10.00"},
			{"0.70", "1.05", "0", "0.7350"},
			{"1.000000000", "1", "0", "1.000000000"},
			{"1.23456789", "1.00000000", "0", "1.2345678900000000"},
			{"1.000000000000000000", "1.000000000000000000", "0", "1.000000000000000000"},
			{"1.000000000000000001", "1.000000000000000001", "0", "1.000000000000000002"},
			{"9.999999999999999999", "9.999999999999999999", "0", "99.99999999999999998"},
			{"0.0000000000000000001", "0.0000000000000000001", "0", "0.0000000000000000000"},
			{"0.0000000000000000001", "0.9999999999999999999", "0", "0.0000000000000000001"},
			{"0.0000000000000000003", "0.9999999999999999999", "0", "0.0000000000000000003"},
			{"0.9999999999999999999", "0.9999999999999999999", "0", "0.9999999999999999998"},
			{"6963.788300835654596", "0.001436", "0", "10.00000000000000000"},

			// Tests from GDA
			{"27583489.6645", "2582471078.04", "2593183.42371", "71233564292579696.34"},
			{"24280.355566", "939577.397653", "2032.013252", "22813275328.80506589"},
			{"7848976432", "-2586831.2281", "137903.517909", "-20303977342780612.62"},
			{"56890.388731", "35872030.4255", "339337.123410", "2040774094814.077745"},
			{"7533543.57445", "360317763928", "5073392.31638", "2714469575205049785"},
			{"437484.00601", "598906432790", "894450638.442", "262011986336578659.5"},
			{"203258304486", "-8628278.8066", "153127.446727", "-1753769320861850379"},
			{"42560533.1774", "-3643605282.86", "178277.96377", "-155073783526334663.6"},
		}

		for _, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			f := MustParse(c.f)
			want := MustParse(c.want)
			got := d.FMA(e, f)
			if got != want {
				t.Errorf("%q.FMA(%q, %q) = %q, want %q", d, e, f, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d, e, f string
			scale   int
		}{
			"overflow 1": {"1", "9999999999999999999", "1", 0},
			"overflow 2": {"1", "9999999999999999999", "0.6", 0},
			"overflow 3": {"1", "-9999999999999999999", "-1", 0},
			"overflow 4": {"1", "-9999999999999999999", "-0.6", 0},
			"overflow 5": {"10000000000", "1000000000", "0", 0},
			"overflow 6": {"1000000000000000000", "10", "0", 0},
			"scale 1":    {"0", "0", "0", -1},
			"scale 2":    {"0", "0", "0", MaxScale + 1},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			f := MustParse(c.f)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.FMAExact(%q, %q, %v) did not panic", d, e, f, c.scale)
					}
				}()
				d.FMAExact(e, f, c.scale)
			})
		}
	})
}

func TestDecimal_Pow(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d     string
			power int
			want  string
		}{
			// Zeroes
			{"0", 0, "1"},
			{"0", 1, "0"},
			{"0", 2, "0"},

			// Ones
			{"1", -2, "1"},
			{"1", -1, "1"},
			{"1", 0, "1"},
			{"1", 1, "1"},
			{"1", 2, "1"},

			// Twos
			{"2", -63, "0.0000000000000000001"},
			{"2", -32, "0.0000000002328306437"},
			{"2", -16, "0.0000152587890625"},
			{"2", -9, "0.001953125"},
			{"2", -8, "0.00390625"},
			{"2", -7, "0.0078125"},
			{"2", -6, "0.015625"},
			{"2", -5, "0.03125"},
			{"2", -4, "0.0625"},
			{"2", -3, "0.125"},
			{"2", -2, "0.25"},
			{"2", -1, "0.5"},
			{"2", 0, "1"},
			{"2", 1, "2"},
			{"2", 2, "4"},
			{"2", 3, "8"},
			{"2", 4, "16"},
			{"2", 5, "32"},
			{"2", 6, "64"},
			{"2", 7, "128"},
			{"2", 8, "256"},
			{"2", 9, "512"},
			{"2", 16, "65536"},
			{"2", 32, "4294967296"},
			{"2", 63, "9223372036854775808"},

			// Squares
			{"-3", 2, "9"},
			{"-2", 2, "4"},
			{"-1", 2, "1"},
			{"0", 2, "0"},
			{"1", 2, "1"},
			{"2", 2, "4"},
			{"3", 2, "9"},
			{"4", 2, "16"},
			{"5", 2, "25"},
			{"6", 2, "36"},
			{"7", 2, "49"},
			{"8", 2, "64"},
			{"9", 2, "81"},
			{"10", 2, "100"},
			{"11", 2, "121"},
			{"12", 2, "144"},
			{"13", 2, "169"},
			{"14", 2, "196"},

			// Cubes
			{"-3", 3, "-27"},
			{"-2", 3, "-8"},
			{"-1", 3, "-1"},
			{"0", 3, "0"},
			{"1", 3, "1"},
			{"2", 3, "8"},
			{"3", 3, "27"},
			{"4", 3, "64"},
			{"5", 3, "125"},
			{"6", 3, "216"},
			{"7", 3, "343"},
			{"8", 3, "512"},
			{"9", 3, "729"},
			{"10", 3, "1000"},
			{"11", 3, "1331"},
			{"12", 3, "1728"},
			{"13", 3, "2197"},
			{"14", 3, "2744"},

			// One Tenth
			{"0.1", 0, "1"},
			{"0.1", 1, "0.1"},
			{"0.1", 2, "0.01"},
			{"0.1", 3, "0.001"},
			{"0.1", 4, "0.0001"},
			{"0.1", 5, "0.00001"},
			{"0.1", 6, "0.000001"},
			{"0.1", 7, "0.0000001"},
			{"0.1", 8, "0.00000001"},
			{"0.1", 9, "0.000000001"},

			// One Half
			{"0.5", 0, "1"},
			{"0.5", 1, "0.5"},
			{"0.5", 2, "0.25"},
			{"0.5", 3, "0.125"},
			{"0.5", 4, "0.0625"},
			{"0.5", 5, "0.03125"},
			{"0.5", 6, "0.015625"},
			{"0.5", 7, "0.0078125"},
			{"0.5", 8, "0.00390625"},
			{"0.5", 9, "0.001953125"},

			// Interest accrual
			{"1.1", 60, "304.4816395414180996"},       // error in the last digit
			{"1.01", 600, "391.5833969993197775"},     // error in the last two digits
			{"1.001", 6000, "402.2211245663552073"},   // error in the last three digits
			{"1.0001", 60000, "403.3077910727185768"}, // error in the last three digits
		}
		for _, c := range cases {
			d := MustParse(c.d)
			got := d.Pow(c.power)
			want := MustParse(c.want)
			if got != want {
				t.Errorf("%q.Pow(%d) = %q, want %q", d, c.power, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d     string
			power int
		}{
			"overflow 1": {"2", 64},
			"overflow 2": {"10", 19},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.Power(%d) did not panic", d, c.power)
					}
				}()
				d.Pow(c.power)
			})
		}
	})
}

func TestDecimal_Abs(t *testing.T) {
	cases := []struct {
		d, want string
	}{
		{"1", "1"},
		{"-1", "1"},
		{"1.00", "1.00"},
		{"-1.00", "1.00"},
		{"0", "0"},
		{"0.0", "0.0"},
		{"0.00", "0.00"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		want := MustParse(c.want)
		got := d.Abs()
		if got != want {
			t.Errorf("%q.Abs() = %q, want %q", d, got, want)
		}
	}
}

func TestDecimal_Neg(t *testing.T) {
	cases := []struct {
		d, want string
	}{
		{"1", "-1"},
		{"-1", "1"},
		{"1.00", "-1.00"},
		{"-1.00", "1.00"},
		{"0", "0"},
		{"0.0", "0.0"},
		{"0.00", "0.00"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		want := MustParse(c.want)
		got := d.Neg()
		if got != want {
			t.Errorf("%q.Neg() = %q, want %q", d, got, want)
		}
	}
}

func TestDecimal_Quo(t *testing.T) {

	t.Run("valid", func(t *testing.T) {
		cases := []struct {
			d, e, want string
		}{
			// Zeros
			{"0", "1.000", "0"},
			{"0.0", "1.000", "0"},
			{"0.00", "1.000", "0"},
			{"0.000", "1.000", "0"},
			{"0.0000", "1.000", "0.0"},
			{"0.00000", "1.000", "0.00"},

			{"0.000", "1", "0.000"},
			{"0.000", "1.0", "0.00"},
			{"0.000", "1.00", "0.0"},
			{"0.000", "1.000", "0"},
			{"0.000", "1.0000", "0"},
			{"0.000", "1.00000", "0"},

			// Ones
			{"1", "1.000", "1"},
			{"1.0", "1.000", "1"},
			{"1.00", "1.000", "1"},
			{"1.000", "1.000", "1"},
			{"1.0000", "1.000", "1.0"},
			{"1.00000", "1.000", "1.00"},

			{"1.000", "1", "1.000"},
			{"1.000", "1.0", "1.00"},
			{"1.000", "1.00", "1.0"},
			{"1.000", "1.000", "1"},
			{"1.000", "1.0000", "1"},
			{"1.000", "1.00000", "1"},

			// Simple cases
			{"1", "1", "1"},
			{"2", "1", "2"},
			{"1", "2", "0.5"},
			{"2", "2", "1"},
			{"0", "1", "0"},
			{"0", "2", "0"},
			{"1.5", "3", "0.5"},
			{"3", "3", "1"},
			{"9999999999999999999", "1", "9999999999999999999"},
			{"9999999999999999999", "9999999999999999999", "1"},

			// Signs
			{"2.4", "1", "2.4"},
			{"2.4", "-1", "-2.4"},
			{"-2.4", "1", "-2.4"},
			{"-2.4", "-1", "2.4"},

			// Scales
			{"2.40", "1", "2.40"},
			{"2.400", "1", "2.400"},
			{"2.4", "2", "1.2"},
			{"2.400", "2", "1.200"},

			// 1 divided by digits
			{"1", "1", "1"},
			{"1", "2", "0.5"},
			{"1", "3", "0.3333333333333333333"},
			{"1", "4", "0.25"},
			{"1", "5", "0.2"},
			{"1", "6", "0.1666666666666666667"},
			{"1", "7", "0.1428571428571428571"},
			{"1", "8", "0.125"},
			{"1", "9", "0.1111111111111111111"},

			// 2 divided by digits
			{"2", "1", "2"},
			{"2", "2", "1"},
			{"2", "3", "0.6666666666666666667"},
			{"2", "4", "0.5"},
			{"2", "5", "0.4"},
			{"2", "6", "0.3333333333333333333"},
			{"2", "7", "0.2857142857142857143"},
			{"2", "8", "0.25"},
			{"2", "9", "0.2222222222222222222"},

			// 2 divided by 3
			{"0.0000000000000000002", "3", "0.0000000000000000001"},
			{"0.0000000000000000002", "3.000000000000000000", "0.0000000000000000001"},
			{"2", "3", "0.6666666666666666667"},
			{"2.000000000000000000", "3", "0.6666666666666666667"},
			{"2", "3.000000000000000000", "0.6666666666666666667"},
			{"2.000000000000000000", "3.000000000000000000", "0.6666666666666666667"},
			{"0.0000000000000000002", "0.0000000000000000003", "0.6666666666666666667"},
			{"2", "0.0000000000000000003", "6666666666666666667"},
			{"2.000000000000000000", "0.0000000000000000003", "6666666666666666667"},

			// Interest accrual
			{"0.0001", "365", "0.0000002739726027397"}, // no error
			{"0.0001", "366", "0.0000002732240437158"}, // no error

			// Captured during fuzzing
			{"0.000000000000000001", "20", "0.000000000000000000"},
			{"105", "0.999999999999999990", "105.0000000000000011"},
			{"0.05", "999999999999999954", "0.0000000000000000001"},
			{"9.99999999999999998", "185", "0.0540540540540540539"},
			{"7", "2.000000000000000002", "3.499999999999999997"},
			{"0.000000009", "999999999999999999", "0.000000000"},
			{"0.0000000000000000001", "9999999999999999999", "0.0000000000000000000"},
			{"9999999999999999999", "2", "5000000000000000000"},
			{"9999999999999999999", "5000000000000000000", "2"},
		}
		for _, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			want := MustParse(c.want)
			got := d.Quo(e)
			if got != want {
				t.Errorf("%q.Quo(%q) = %q, want %q", d, e, got, want)
			}
		}
	})

	t.Run("panic", func(t *testing.T) {
		cases := map[string]struct {
			d, e  string
			scale int
		}{
			"zero 1":     {"1", "0", 0},
			"overflow 1": {"9999999999999999999", "0.001", 0},
			"scale 1":    {"2", "1", -1},
			"scale 2":    {"2", "1", MaxScale + 1},
		}
		for name, c := range cases {
			d := MustParse(c.d)
			e := MustParse(c.e)
			t.Run(name, func(t *testing.T) {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("%q.QuoExact(%q, %v) did not panic", d, e, c.scale)
					}
				}()
				d.QuoExact(e, c.scale)
			})
		}
	})
}

func TestDecimal_QuoRem(t *testing.T) {
	cases := []struct {
		d, e, wantQuo, wantRem string
	}{
		// Zeros
		{"0", "1.000", "0", "0.000"},
		{"0.0", "1.000", "0", "0.000"},
		{"0.00", "1.000", "0", "0.000"},
		{"0.000", "1.000", "0", "0.000"},
		{"0.0000", "1.000", "0", "0.0000"},
		{"0.00000", "1.000", "0", "0.00000"},

		{"0.000", "1", "0", "0.000"},
		{"0.000", "1.0", "0", "0.000"},
		{"0.000", "1.00", "0", "0.000"},
		{"0.000", "1.000", "0", "0.000"},
		{"0.000", "1.0000", "0", "0.0000"},
		{"0.000", "1.00000", "0", "0.00000"},

		// Ones
		{"1", "1.000", "1", "0.000"},
		{"1.0", "1.000", "1", "0.000"},
		{"1.00", "1.000", "1", "0.000"},
		{"1.000", "1.000", "1", "0.000"},
		{"1.0000", "1.000", "1", "0.0000"},
		{"1.00000", "1.000", "1", "0.00000"},

		{"1.000", "1", "1", "0.000"},
		{"1.000", "1.0", "1", "0.000"},
		{"1.000", "1.00", "1", "0.000"},
		{"1.000", "1.000", "1", "0.000"},
		{"1.000", "1.0000", "1", "0.0000"},
		{"1.000", "1.00000", "1", "0.00000"},

		// Signs
		{"2.4", "1", "2", "0.4"},
		{"2.4", "-1", "-2", "0.4"},
		{"-2.4", "1", "-2", "-0.4"},
		{"-2.4", "-1", "2", "-0.4"},

		// Scales
		{"2.40", "1", "2", "0.40"},
		{"2.400", "1", "2", "0.400"},
		{"2.4", "2", "1", "0.4"},
		{"2.400", "2", "1", "0.400"},

		// 1 divided by digits
		{"1", "1", "1", "0"},
		{"1", "2", "0", "1"},
		{"1", "3", "0", "1"},
		{"1", "4", "0", "1"},
		{"1", "5", "0", "1"},
		{"1", "6", "0", "1"},
		{"1", "7", "0", "1"},
		{"1", "8", "0", "1"},
		{"1", "9", "0", "1"},

		// 2 divided by digits
		{"2", "1", "2", "0"},
		{"2", "2", "1", "0"},
		{"2", "3", "0", "2"},
		{"2", "4", "0", "2"},
		{"2", "5", "0", "2"},
		{"2", "6", "0", "2"},
		{"2", "7", "0", "2"},
		{"2", "8", "0", "2"},
		{"2", "9", "0", "2"},

		// Other tests
		{"12345", "4.999", "2469", "2.469"},
		{"12345", "4.99", "2473", "4.73"},
		{"12345", "4.9", "2519", "1.9"},
		{"12345", "5", "2469", "0"},
		{"12345", "5.1", "2420", "3.0"},
		{"12345", "5.01", "2464", "0.36"},
		{"12345", "5.001", "2468", "2.532"},

		{"41", "21", "1", "20"},
		{"4.2", "3.1000003", "1", "1.0999997"},
		{"1.000000000000000000", "0.000000000000000003", "333333333333333333", "0.000000000000000001"},
		{"1.000000000000000001", "0.000000000000000003", "333333333333333333", "0.000000000000000002"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		e := MustParse(c.e)
		wantQuo := MustParse(c.wantQuo)
		wantRem := MustParse(c.wantRem)
		gotQuo, gotRem := d.QuoRem(e)
		if gotQuo != wantQuo || gotRem != wantRem {
			t.Errorf("%q.QuoRem(%q) = (%q, %q), want (%q, %q)", d, e, gotQuo, gotRem, wantQuo, wantRem)
		}
	}
}

func TestDecimal_Cmp(t *testing.T) {
	cases := []struct {
		d, e string
		want int
	}{
		{"-2", "-2", 0},
		{"-2", "-1", -1},
		{"-2", "0", -1},
		{"-2", "1", -1},
		{"-2", "2", -1},
		{"-1", "-2", 1},
		{"-1", "-1", 0},
		{"-1", "0", -1},
		{"-1", "1", -1},
		{"-1", "2", -1},
		{"0", "-2", 1},
		{"0", "-1", 1},
		{"0", "0", 0},
		{"0", "1", -1},
		{"0", "2", -1},
		{"1", "-2", 1},
		{"1", "-1", 1},
		{"1", "0", 1},
		{"1", "1", 0},
		{"1", "2", -1},
		{"2", "-2", 1},
		{"2", "-1", 1},
		{"2", "0", 1},
		{"2", "1", 1},
		{"2", "2", 0},
		{"2", "2.0", 0},
		{"2", "2.00", 0},
		{"2", "2.000", 0},
		{"2", "2.0000", 0},
		{"2", "2.00000", 0},
		{"2", "2.000000", 0},
		{"2", "2.0000000", 0},
		{"2", "2.00000000", 0},
		{"9999999999999999999", "0.9999999999999999999", 1},
		{"0.9999999999999999999", "9999999999999999999", -1},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		e := MustParse(c.e)
		got := d.Cmp(e)
		if got != c.want {
			t.Errorf("%q.Cmp(%q) = %v, want %v", d, e, got, c.want)
		}
	}
}

func TestDecimal_Max(t *testing.T) {
	cases := []struct {
		d, e, want string
	}{
		{"-2", "-2", "-2"},
		{"-2", "-1", "-1"},
		{"-2", "0", "0"},
		{"-2", "1", "1"},
		{"-2", "2", "2"},
		{"-1", "-2", "-1"},
		{"-1", "-1", "-1"},
		{"-1", "0", "0"},
		{"-1", "1", "1"},
		{"-1", "2", "2"},
		{"0", "-2", "0"},
		{"0", "-1", "0"},
		{"0", "0", "0"},
		{"0", "1", "1"},
		{"0", "2", "2"},
		{"1", "-2", "1"},
		{"1", "-1", "1"},
		{"1", "0", "1"},
		{"1", "1", "1"},
		{"1", "2", "2"},
		{"2", "-2", "2"},
		{"2", "-1", "2"},
		{"2", "0", "2"},
		{"2", "1", "2"},
		{"2", "2", "2"},
		{"0.000", "0.0", "0.0"},
		{"0.0", "0.000", "0.0"},
		{"-0.000", "-0.0", "0.0"},
		{"-0.0", "-0.000", "0.0"},
		{"1.23", "1.2300", "1.23"},
		{"1.2300", "1.23", "1.23"},
		{"-1.23", "-1.2300", "-1.23"},
		{"-1.2300", "-1.23", "-1.23"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		e := MustParse(c.e)
		want := MustParse(c.want)
		got := d.Max(e)
		if got != want {
			t.Errorf("%q.Max(%q) = %q, want %q", d, e, got, want)
		}
	}
}

func TestDecimal_Min(t *testing.T) {
	cases := []struct {
		d, e, want string
	}{
		{"-2", "-2", "-2"},
		{"-2", "-1", "-2"},
		{"-2", "0", "-2"},
		{"-2", "1", "-2"},
		{"-2", "2", "-2"},
		{"-1", "-2", "-2"},
		{"-1", "-1", "-1"},
		{"-1", "0", "-1"},
		{"-1", "1", "-1"},
		{"-1", "2", "-1"},
		{"0", "-2", "-2"},
		{"0", "-1", "-1"},
		{"0", "0", "0"},
		{"0", "1", "0"},
		{"0", "2", "0"},
		{"1", "-2", "-2"},
		{"1", "-1", "-1"},
		{"1", "0", "0"},
		{"1", "1", "1"},
		{"1", "2", "1"},
		{"2", "-2", "-2"},
		{"2", "-1", "-1"},
		{"2", "0", "0"},
		{"2", "1", "1"},
		{"2", "2", "2"},
		{"0.000", "0.0", "0.000"},
		{"0.0", "0.000", "0.000"},
		{"-0.000", "-0.0", "0.000"},
		{"-0.0", "-0.000", "0.000"},
		{"1.23", "1.2300", "1.2300"},
		{"1.2300", "1.23", "1.2300"},
		{"-1.23", "-1.2300", "-1.2300"},
		{"-1.2300", "-1.23", "-1.2300"},
	}
	for _, c := range cases {
		d := MustParse(c.d)
		e := MustParse(c.e)
		want := MustParse(c.want)
		got := d.Min(e)
		if got != want {
			t.Errorf("%q.Min(%q) = %q, want %q", d, e, got, want)
		}
	}
}

/******************************************************
* Fuzzing
******************************************************/

var (
	corpus = []struct {
		neg   bool
		scale int
		coef  uint64
	}{
		{false, 0, 9999999999999999999},
		{false, 1, 9999999999999999999},
		{false, 0, 1000000000000000000},
		{false, 19, 9999999999999999999},
		{false, 0, 7},
		{false, 0, 3},
		{false, 0, 2},
		{false, 0, 1},
		{false, 18, 1000000000000000001},
		{false, 19, 3},
		{false, 19, 2},
		{false, 19, 1},
		{false, 0, 0},
		{false, 19, 0},
		{true, 0, 9999999999999999999},
		{true, 1, 9999999999999999999},
		{true, 0, 1000000000000000000},
		{true, 19, 9999999999999999999},
		{true, 0, 7},
		{true, 0, 3},
		{true, 0, 2},
		{true, 0, 1},
		{true, 18, 1000000000000000001},
		{true, 19, 3},
		{true, 19, 2},
		{true, 19, 1},
	}
)

func FuzzDecimal_String_ParseVsString(f *testing.F) {

	for _, d := range corpus {
		f.Add(d.neg, d.scale, d.coef)
	}

	f.Fuzz(
		func(t *testing.T, neg bool, scale int, coef uint64) {
			want, err := newDecimal(neg, fint(coef), scale)
			if err != nil {
				t.Skip()
				return
			}

			str := want.String()
			got, err := Parse(str)
			if err != nil {
				t.Errorf("Parse(%q) failed: %v", str, err)
				return
			}

			if got != want {
				t.Errorf("Parse(%q) = %v, want %v", str, got, want)
				return
			}
		},
	)
}

func FuzzDecimal_Mul_FastVsSlow(f *testing.F) {

	for _, d := range corpus {
		for _, e := range corpus {
			for s := 0; s <= MaxScale; s++ {
				f.Add(d.neg, d.scale, d.coef, e.neg, e.scale, e.coef, s)
			}
		}
	}

	f.Fuzz(
		func(t *testing.T, dneg bool, dscale int, dcoef uint64, eneg bool, escale int, ecoef uint64, scale int) {
			if scale < 0 || MaxScale < scale {
				t.Skip()
				return
			}

			d, err := newDecimal(dneg, fint(dcoef), dscale)
			if err != nil {
				t.Skip()
				return
			}

			e, err := newDecimal(eneg, fint(ecoef), escale)
			if err != nil {
				t.Skip()
				return
			}

			f, err := mulFast(d, e, scale)
			if err != nil {
				if errors.Is(err, errCoefficientOverflow) {
					t.Skip() // Coefficient overflow is an expected error in fast multiplication
				} else {
					t.Errorf("mulFast(%q, %q, %v) failed: %v", d, e, scale, err)
				}
				return
			}

			s, err := mulSlow(d, e, scale)
			if err != nil {
				t.Errorf("mulSlow(%q, %q, %v) failed: %v", d, e, scale, err)
				return
			}
			if s.Scale() < scale {
				t.Errorf("mulSlow(%q, %q, %v).Scale() = %v, want >= %v", d, e, scale, s.Scale(), scale)
				return
			}

			if s.Cmp(f) != 0 {
				t.Errorf("mulSlow(%q, %q, %v) = %q, whereas mulFast(%q, %q, %v) = %q", d, e, scale, s, d, e, scale, f)
			}
		},
	)
}

func FuzzDecimal_FMA_FastVsSlow(f *testing.F) {

	for _, d := range corpus {
		for _, e := range corpus {
			for _, g := range corpus {
				for s := 0; s <= MaxScale; s++ {
					f.Add(d.neg, d.scale, d.coef, e.neg, e.scale, e.coef, g.neg, g.scale, g.coef, s)
				}
			}
		}
	}

	f.Fuzz(
		func(t *testing.T, dneg bool, dscale int, dcoef uint64, eneg bool, escale int, ecoef uint64, gneg bool, gscale int, gcoef uint64, scale int) {
			if scale < 0 || MaxScale < scale {
				t.Skip()
				return
			}

			d, err := newDecimal(dneg, fint(dcoef), dscale)
			if err != nil {
				t.Skip()
				return
			}

			e, err := newDecimal(eneg, fint(ecoef), escale)
			if err != nil {
				t.Skip()
				return
			}

			g, err := newDecimal(gneg, fint(gcoef), gscale)
			if err != nil {
				t.Skip()
				return
			}

			f, err := fmaFast(d, e, g, scale)
			if err != nil {
				if errors.Is(err, errCoefficientOverflow) {
					t.Skip() // Coefficient overflow is an expected error in fast fused multiplication-addition
				} else {
					t.Errorf("fmaFast(%q, %q, %q, %v) failed: %v", d, e, g, scale, err)
				}
				return
			}

			s, err := fmaSlow(d, e, g, scale)
			if err != nil {
				t.Errorf("fmaSlow(%q, %q, %q, %v) failed: %v", d, e, g, scale, err)
				return
			}
			if s.Scale() < scale {
				t.Errorf("fmaSlow(%q, %q, %q, %v).Scale() = %v, want >= %v", d, e, g, scale, s.Scale(), scale)
				return
			}

			if s.Cmp(f) != 0 {
				t.Errorf("fmaSlow(%q, %q, %q, %v) = %q, whereas fmaFast(%q, %q, %q, %v) = %q", d, e, g, scale, s, d, e, g, scale, f)
			}
		},
	)
}

func FuzzDecimal_Add_FastVsSlow(f *testing.F) {

	for _, d := range corpus {
		for _, e := range corpus {
			for s := 0; s <= MaxScale; s++ {
				f.Add(d.neg, d.scale, d.coef, e.neg, e.scale, e.coef, s)
			}
		}
	}

	f.Fuzz(
		func(t *testing.T, dneg bool, dscale int, dcoef uint64, eneg bool, escale int, ecoef uint64, scale int) {
			if scale < 0 || MaxScale < scale {
				t.Skip()
				return
			}

			d, err := newDecimal(dneg, fint(dcoef), dscale)
			if err != nil {
				t.Skip()
				return
			}

			e, err := newDecimal(eneg, fint(ecoef), escale)
			if err != nil {
				t.Skip()
				return
			}

			f, err := addFast(d, e, scale)
			if err != nil {
				if errors.Is(err, errCoefficientOverflow) {
					t.Skip() // Coefficient overflow is an expected error in fast addition
				} else {
					t.Errorf("addFast(%q, %q, %v) failed: %v", d, e, scale, err)
				}
				return
			}

			s, err := addSlow(d, e, scale)
			if err != nil {
				t.Errorf("addSlow(%q, %q, %v) failed: %v", d, e, scale, err)
				return
			}
			if s.Scale() < scale {
				t.Errorf("addSlow(%q, %q, %v).Scale() = %v, want >= %v", d, e, scale, s.Scale(), scale)
				return
			}

			if s.Cmp(f) != 0 {
				t.Errorf("addSlow(%q, %q, %v) = %q, whereas addFast(%q, %q, %v) = %q", d, e, scale, s, d, e, scale, f)
			}
		},
	)
}

func FuzzDecimal_Quo_FastVsSlow(f *testing.F) {

	for _, d := range corpus {
		for _, e := range corpus {
			for s := 0; s <= MaxScale; s++ {
				f.Add(d.neg, d.scale, d.coef, e.neg, e.scale, e.coef, s)
			}
		}
	}

	f.Fuzz(
		func(t *testing.T, dneg bool, dscale int, dcoef uint64, eneg bool, escale int, ecoef uint64, scale int) {
			if scale < 0 || MaxScale < scale {
				t.Skip()
				return
			}
			if dcoef == 0 || ecoef == 0 {
				t.Skip()
				return
			}

			d, err := newDecimal(dneg, fint(dcoef), dscale)
			if err != nil {
				t.Skip()
				return
			}

			e, err := newDecimal(eneg, fint(ecoef), escale)
			if err != nil {
				t.Skip()
				return
			}

			f, err := quoFast(d, e, scale)
			if err != nil {
				if errors.Is(err, errCoefficientOverflow) {
					t.Skip() // Coefficient overflow is an expected error in fast division
				} else {
					t.Errorf("quoFast(%q, %q, %v) failed: %v", d, e, scale, err)
				}
				return
			}

			s, err := quoSlow(d, e, scale)
			if err != nil {
				t.Errorf("quoSlow(%q, %q, %v) failed: %v", d, e, scale, err)
				return
			}
			if s.Scale() < scale {
				t.Errorf("quoSlow(%q, %q, %v).Scale() = %v, want >= %v", d, e, scale, s.Scale(), scale)
				return
			}

			if s.Cmp(f) != 0 {
				t.Errorf("quoSlow(%q, %q, %v) = %q, whereas quoFast(%q, %q, %v) = %q", d, e, scale, s, d, e, scale, f)
			}
		},
	)
}

func FuzzDecimal_Cmp_FastVsSlow(f *testing.F) {

	for _, d := range corpus {
		for _, e := range corpus {
			f.Add(d.neg, d.scale, d.coef, e.neg, e.scale, e.coef)
		}
	}

	f.Fuzz(
		func(t *testing.T, dneg bool, dscale int, dcoef uint64, eneg bool, escale int, ecoef uint64) {
			d, err := newDecimal(dneg, fint(dcoef), dscale)
			if err != nil {
				t.Skip()
				return
			}

			e, err := newDecimal(eneg, fint(ecoef), escale)
			if err != nil {
				t.Skip()
				return
			}

			f, err := cmpFast(d, e)
			if err != nil {
				if errors.Is(err, errCoefficientOverflow) {
					t.Skip() // Coefficient overflow is an expected error in fast comparison
				} else {
					t.Errorf("cmpFast(%q, %q) failed: %v", d, e, err)
				}
				return
			}

			s := cmpSlow(d, e)
			if s != f {
				t.Errorf("cmpSlow(%q, %q) = %v, whereas cmpFast(%q, %q) = %v", d, e, s, d, e, f)
			}
		},
	)
}
